\input texinfo.tex
@c %**start of header
@setfilename vicare-expat.info
@settitle Expat backend for Vicare
@c %**end of header

@include version.texi
@include macros.texi

@macro expatref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,expat}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Expat backend for Vicare

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare/Expat

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-expat

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi.ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2012


@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @version{} of @value{PACKAGE}, a
distribution of C and Scheme libraries for Vicare Scheme, an @rnrs{6}
compliant Scheme implementation; it provides bindings for the Expat C
language library, an @axml{} parser library.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}

@noindent
Expat is available at:

@center @url{http://expat.sourceforge.net/}

@noindent
the @axml{} 1.0 specification is available from:

@center @url{http://www.w3.org/TR/REC-xml/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-expat: (vicare-expat). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* parsers::                     Building and running parsers.
* handlers::                    Building and registering callbacks.
* version::                     Expat version informations.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


Vicare Scheme is an @rnrs{6} compliant Scheme language implementation in
the form of a native compiler for x86 architectures, officially
supporting @gnu{}+Linux systems.  @value{PACKAGE} is a distribution of C
language and Scheme language libraries for Vicare Scheme; it provides
bindings for the Expat C language library, an @axml{} parser library.

While @value{PACKAGE} can be used alone, its purpose is to provide a
backend Expat interface for Nausicaa/Expat: a higher level interface
adding syntactic sugar.

The last time the author bothered to update this paragraph, he had
tested Expat version 2.0.1; the Expat library is available at:

@center @url{http://expat.sourceforge.net/}

@noindent
notice that unofficial Expat documentation in Texinfo format is
available in the Nimby-Doc project at:

@center @url{http://github.com/marcomaggi/nimby-doc}

@noindent
and also online:

@center @url{http://marcomaggi.github.com/docs/expat.html}

@noindent
the @axml{} 1.0 specification is available from:

@center @url{http://www.w3.org/TR/REC-xml/}

Expat must be compiled to handle @utf{}-8 strings.

The package installs a C language library implementing wrapper C
functions for the C language Expat library; on top of this, the Scheme
library @library{vicare expat} exports one binding for each Expat public
function, with the exception of:

@example
XML_ParserCreateMM
XML_MemMalloc
XML_MemRealloc
XML_MemFree
XML_SetUnknownEncodingHandler
@end example

@noindent
additionally the library @library{vicare expat constants} exports one
binding for each constant value defined in the C language header
@file{expat.h}.

This document contains only a brief description of the functions: refer
to the Expat's documentation for details.

Here is an example program:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<!-- this is a test document -->\
   <stuff>\
   <thing colour=\"yellow\">\
   <alpha>one</alpha>\
   <beta>two</beta>\
   </thing>\
   <thing>\
   <alpha>123</alpha>\
   <beta>456</beta>\
   </thing>\
   </stuff>"))

(define (start-callback data element attributes)
  (let ((element    (ffi.cstring->string element))
        (attributes (ffi.argv->strings attributes)))
    (pretty-print (list 'start element attributes))))

(define (end-callback data element)
  (let ((element (ffi.cstring->string element)))
    (pretty-print (list 'end element))))

(define (cdata-callback data buf.ptr buf.len)
  (let ((text (ffi.cstring->string buf.ptr buf.len)))
    (pretty-print (list 'cdata text))))

(define (comment-callback data cstr)
  (let ((text (ffi.cstring->string cstr)))
    (pretty-print (list 'comment text))))

(let ((parser   (XML_ParserCreate))
      (start    (XML_StartElementHandler  start-callback))
      (end      (XML_EndElementHandler    end-callback))
      (cdata    (XML_CharacterDataHandler cdata-callback))
      (comment  (XML_CommentHandler       comment-callback)))
  (XML_SetElementHandler       parser start end)
  (XML_SetCharacterDataHandler parser cdata)
  (XML_SetCommentHandler       parser comment)
  (XML_Parse parser xml-utf8 #f #t)
  (ffi.free-c-callback start)
  (ffi.free-c-callback end)
  (ffi.free-c-callback cdata)
  (ffi.free-c-callback comment))

(flush-output-port (current-output-port))
@end example

@noindent
which prints:

@example
(comment " this is a test document ")
(start "stuff" ())
(start "thing" ("colour" "yellow"))
(start "alpha" ())
(cdata "one")
(end "alpha")
(start "beta" ())
(cdata "two")
(end "beta")
(end "thing")
(start "thing" ())
(start "alpha" ())
(cdata "123")
(end "alpha")
(start "beta" ())
(cdata "456")
(end "beta")
(end "thing")
(end "stuff")
@end example

@c page
@node parsers
@chapter Building and running parsers


@menu
* parsers create::              Creating parsers.
* parsers external::            Creating external entities parsers.
* parsers parsing::             Parsing data.
* parsers namespaces::          Using namespaces.
* parsers stop::                Stopping and resuming.
* parsers status::              Parsing status.
* parsers report::              Reporting errors.
* parsers misc::                Miscellaneous functions.
@end menu

@c page
@node parsers create
@section Creating parsers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_ParserCreate
@defunx XML_ParserCreate @var{encoding}
@expatref{api create, XML_ParserCreate}.  Build a new parser and return
a pointer object referencing it.  Values returned by this function must
be finalised with @func{XML_ParserFree}; this will happen automatically
when the pointer object is garbage collected.

The optional @var{encoding} must be @false{} or one of the Scheme
symbols: @code{UTF-8}, @code{UTF-16}, @code{ISO-8859-1},
@code{US-ASCII}; when @var{encoding} is not used or it is @false{}: the
parser will honour the encoding specification in the document.
@end defun


@defun XML_ParserFree @var{parser}
@expatref{api create, XML_ParserFree}.  Release all the resources
associated to the pointer object @var{parser}, then mutate @var{parser}
to represent the @cnull{} pointer; return unspecified values.  It is
safe to apply this function multiple times to the same @var{parser}
object: the first time it will release the resources, subsequent times
nothing will happen.
@end defun


@defun XML_ParserReset @var{parser}
@defunx XML_ParserReset @var{parser} @var{encoding}
@expatref{api create, XML_ParserReset}.  Reset a parser so that it can
be used again; return a boolean value: @true{} if success, @false{} if
this parser cannot be reset.  @var{encoding} is as in
@func{XML_ParserCreate}.
@end defun


@defun XML_SetEncoding @var{parser} @var{encoding}
@expatref{api misc, XML_SetEncoding}.  Set the encoding to be used while
parsing.  @var{encoding} is as in @func{XML_ParserCreate}.  Return a
fixnum representing a status code.
@end defun

@c page
@node parsers external
@section Creating external entities parsers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_SetParamEntityParsing @var{parser} @var{code}
@expatref{api misc, XML_SetParamEntityParsing}.  Enable or disable
external entity parsing according to @var{code}, which must be a fixnum
among:

@example
XML_PARAM_ENTITY_PARSING_NEVER
XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE
XML_PARAM_ENTITY_PARSING_ALWAYS
@end example
@end defun


@defun XML_ExternalEntityParserCreate @var{parser} @var{context} @var{encoding}
@expatref{api external, XML_ExternalEntityParserCreate}.  Build a new
parser to parse an external entity for @var{parser} and return a pointer
object referencing it.  Values returned by this function must be
finalised with @func{XML_ParserFree}; this will happen automatically
when the pointer object is garbage collected.

@var{parser} is a pointer object to the main parser.  @var{context} must
be a pointer object.  @var{encoding} is as in @func{XML_ParserCreate}.
@end defun


@defun XML_ExternalEntityRefHandler @var{scheme-callback}
@defunx XML_SetExternalEntityRefHandler @var{parser} @var{c-callback}
@expatref{api external, XML_ExternalEntityRefHandler}.  Maker and setter
for external entity handler.
@end defun


The following is a skeleton program showing how to parse an external
@dtd{}:

@smallexample
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define dtd-utf8
  (string->utf8 "<!ELEMENT ball EMPTY>
                 <!ATTLIST ball colour CDATA #REQUIRED>"))

(define (ext-callback parser context base
                      system-id public-id)
  (let* ((parser (XML_ExternalEntityParserCreate parser context 'UTF-8))
         (rv     (XML_Parse parser dtd-utf8 #f #t)))
    (pretty-print
     (list 'external-entity rv
           (ffi.pointer-null? context)
           (ffi.pointer-null? base)
           (ffi.cstring->string system-id)
           (ffi.pointer-null? public-id)))
    XML_STATUS_OK))

(define (doit xml-utf8)
  (let* ((parser (XML_ParserCreate))
         (ext    (XML_ExternalEntityRefHandler ext-callback)))
    (XML_SetParamEntityParsing parser
       XML_PARAM_ENTITY_PARSING_ALWAYS)
    (XML_SetExternalEntityRefHandler parser ext)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback ext)
    (flush-output-port (current-output-port))))

(doit (string->utf8
  "<!DOCTYPE toys SYSTEM 'http://localhost/toys'>
   <toys><ball colour='red'/></toys>"))
@print{} (external-entity 1 #t #t "http://localhost/toys" #t)

(doit (string->utf8
  "<!DOCTYPE toys PUBLIC 'The Toys' 'http://localhost/toys'>
   <toys><ball colour='red'/></toys>"))
@print{} (external-entity 1 #t #t "http://localhost/toys" #f)
@end smallexample

@c page
@node parsers parsing
@section Parsing data


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@defun XML_Parse @var{parser} @var{buffer} @var{buflen}
@defunx XML_Parse @var{parser} @var{buffer} @var{buflen} @var{final?}
@expatref{api parse, XML_Parse}.  Parse the next portion of the
document; return a fixnum representing a status code.

@var{buffer} must be a bytevector or a pointer object.  @var{buflen}
must be @false{} or a non--negative exact integer in the range of the
@code{int} C language type.  If @var{buffer} is a pointer: @var{buflen}
must be an integer representing the number of bytes to consume from the
buffer; if @var{buffer} is a bytevector: @var{buflen} is ignored and the
whole bytevector is consumed.

If @var{final?} is true: expect this buffer to contain the end of the
document; @var{final?} defaults to @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Parsing data from an internal buffer


@defun XML_GetBuffer @var{parser} @var{buflen}
@expatref{api parse, XML_GetBuffer}.  Allocate an internal buffer
@var{buflen} bytes wide and return a pointer object to it; return
@false{} if the allocation fails.  The returned value is meant to be
filled with the next portion of the document and processed by
@func{XML_ParseBuffer}.
@end defun


@defun XML_ParseBuffer @var{parser} @var{buflen} @var{final?}
@expatref{api parse, XML_ParseBuffer}.  Parse the next portion of the
document from the internal buffer allocated by a previous call to
@func{XML_GetBuffer}.  Return a fixnum representing a status code.
@end defun


The following skeleton program shows the mechanics of using an internal
buffer:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml
  (string->utf8
    "<!DOCTYPE toys SYSTEM 'http://localhost/toys'>
     <toys><ball colour='red'/></toys>"))

(let ((parser  (XML_ParserCreate 'UTF-8))
      (buflen  (bytevector-length data))
      (buffer  (XML_GetBuffer parser buflen)))
  (ffi.memory-copy buffer 0 data 0 buflen)
  (XML_ParseBuffer parser buflen #t))
@end example

@c page
@node parsers namespaces
@section Using namespaces


The use of namespaces in @axml{} 1.0 is defined in the recommendation
at:

@center @url{http://www.w3.org/TR/xml-names/}

@noindent
and allows to tag @axml{} elements with the same name as belonging to
different sets.  When first learning about @axml{} namespaces, remember
that: namespaces are @strong{not} for modular @dtd{} composition.


@defun XML_ParserCreateNS @var{encoding} @var{namespace-separator}
@expatref{api create, XML_ParserCreateNS}.  Build a new parser, having
namespace processing in effect, and return a pointer object referencing
it.  Values returned by this function must be finalised with
@func{XML_ParserFree}; this will happen automatically when the pointer
object is garbage collected.

@var{encoding} is as in @func{XML_ParserCreate}.
@var{namespace-separator} must be a Scheme character in the @ascii{}
range.
@end defun


@defun XML_SetReturnNSTriplet @var{parser} @var{do-nst?}
@expatref{api misc, XML_SetReturnNSTriplet}.  If @var{do-nst?} is true:
turn on returning namespace qualified names as triplets: @uri{}, local
name, prefix, rather than the default pairs: @uri{}, local name; if
@var{do-nst?} is false: turn this off.
@end defun


The following examples show a simple use of namespace; first let's take
the following as program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (doit xml-utf8)
  (define (start-callback data element attributes)
    (pretty-print
     (list 'start
           (ffi.cstring->string element)
           (ffi.argv->strings attributes))))
  (define (end-callback data element)
    (pretty-print
     (list 'end
           (ffi.cstring->string element))))
  (let ((parser  (XML_ParserCreateNS 'UTF-8 #\:))
        (start   (XML_StartElementHandler start-callback))
        (end     (XML_EndElementHandler   end-callback)))
    (XML_SetElementHandler parser start end)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback start)
    (ffi.free-c-callback end)
    (flush-output-port (current-output-port))))
@end example

@noindent
then the following form:

@example
(doit
  (string->utf8
   "<?xml version='1.0'?>
    <!DOCTYPE toys [
      <!ELEMENT ball EMPTY>
      <!ATTLIST ball colour CDATA #REQUIRED>
    ]>
   <toys xmlns:blue='http://localhost/blue'
         xmlns:red='http://localhost/red'>\
   <blue:ball colour='yellow'/>\
   <red:ball  colour='purple'/>\
   </toys>"))
@end example

@noindent
prints the output:

@example
(start "toys" ())
(start "http://localhost/blue:ball" ("colour" "yellow"))
(end "http://localhost/blue:ball")
(start "http://localhost/red:ball" ("colour" "purple"))
(end "http://localhost/red:ball")
(end "toys")
@end example

@noindent
the following form shows use of the default namespace:

@example
(doit
  (string->utf8
    "<?xml version='1.0'?>
     <!DOCTYPE toys [
       <!ELEMENT ball EMPTY>
       <!ATTLIST ball colour CDATA #REQUIRED>
     ]>
     <toys xmlns='http://localhost/blue'>
       <ball colour='yellow'/>
       <ball  colour='purple'/>
     </toys>"))
@end example

@noindent
the output is:

@example
(start "http://localhost/blue:toys" ())
(start "http://localhost/blue:ball" ("colour" "yellow"))
(end "http://localhost/blue:ball")
(start "http://localhost/blue:ball" ("colour" "purple"))
(end "http://localhost/blue:ball")
(end "http://localhost/blue:toys")
@end example

@noindent
now let's define the following function which makes use of
@func{XML_SetReturnNSTriplet}:

@example
(define (doit-with-triplet xml-utf8)
  (define (start-callback data element attributes)
    (pretty-print
     (list 'start
           (ffi.cstring->string element)
           (ffi.argv->strings attributes))))
  (define (end-callback data element)
    (pretty-print
     (list 'end
           (ffi.cstring->string element))))
  (let ((parser  (XML_ParserCreateNS 'UTF-8 #\:))
        (start   (XML_StartElementHandler start-callback))
        (end     (XML_EndElementHandler   end-callback)))
    (XML_SetReturnNSTriplet parser #t)
    (XML_SetElementHandler parser start end)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback start)
    (ffi.free-c-callback end)
    (flush-output-port (current-output-port))))
@end example

@noindent
the following form:

@example
(doit-with-triplet
 (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys [
     <!ELEMENT ball EMPTY>
     <!ATTLIST ball colour CDATA #REQUIRED>
   ]>
   <toys xmlns:blue='http://localhost/blue'
         xmlns:red='http://localhost/red'>
   <blue:ball colour='yellow'/>
   <red:ball  colour='purple'/>
   </toys>")))
@end example

@noindent
prints the output:

@example
(start "toys" ())
(start "http://localhost/blue:ball:blue" ("colour" "yellow"))
(end "http://localhost/blue:ball:blue")
(start "http://localhost/red:ball:red" ("colour" "purple"))
(end "http://localhost/red:ball:red")
(end "toys")
@end example

@c page
@node parsers stop
@section Stopping and resuming


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@defun XML_StopParser @var{parser} @var{resumable?}
@expatref{api parse, XML_StopParser}.  Stop parsing causing the parse
function to return; return a fixnum representing a status code.  If
@var{resumable?} is true: suspend the parsing for later resumption; if
@var{resumable?} is false: abort the parsing.
@end defun


@defun XML_ResumeParser @var{parser}
@expatref{api parse, XML_ResumeParser}.  Resume parsing for a suspended
parser.  A call to this function is like a call to @func{XML_Parse} or
@func{XML_ParseBuffer}.
@end defun


The following skeleton program shows the mechanics of aborting parsing:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<?xml version='1.0'?>
    <!DOCTYPE toys [
      <!ELEMENT ball EMPTY>
      <!ATTLIST ball colour CDATA #REQUIRED>
    ]>
    <toys><ball colour='red'/></toys>"))

(define (start-callback parser element attributes)
  (let ((status (XML_GetParsingStatus parser)))
    (unless (= XML_STATUS_SUSPENDED
               (parsing-status-parsing status))
      (XML_StopParser parser #f))))

(let ((parser  (XML_ParserCreate))
      (start   (XML_StartElementHandler start-callback)))
  (XML_SetStartElementHandler parser start)
  (XML_SetUserData parser parser)
  (XML_Parse parser xml-utf8 #f #t)     @result{} XML_STATUS_ERROR
  (ffi.free-c-callback start)
  (XML_GetErrorCode parser))            @result{} XML_ERROR_ABORTED
@end example

@noindent
the following skeleton program shows the mechanics of stopping parsing
and then resuming:

@smallexample
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<?xml version='1.0'?>
    <!DOCTYPE toys [
      <!ELEMENT ball EMPTY>
      <!ATTLIST ball colour CDATA #REQUIRED>
    ]>
    <toys><ball colour='red'/></toys>"))

(define (start-callback-and-suspend parser element attributes)
  (XML_StopParser parser #t))

(define (start-callback parser element attributes)
  (void))

(let* ((parser   (XML_ParserCreate))
       (suspend  (XML_StartElementHandler start-callback-and-suspend)))
  (XML_SetStartElementHandler parser suspend)
  (XML_SetUserData parser parser)
  (XML_Parse parser xml-utf8 #f #t)     @result{} XML_STATUS_SUSPENDED
  (ffi.free-c-callback suspend)
  (let ((start (XML_StartElementHandler start-callback)))
    (XML_SetStartElementHandler parser start)
    (XML_ResumeParser parser)           @result{} XML_STATUS_OK
    (ffi.free-c-callback start)))
@end smallexample

@c page
@node parsers status
@section Parsing status


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@deftp {Structure Type} xml-parsing-status
@expatref{api parse, XML_ParsingStatus}.  Structure representing the
current parser status as mirror of the C data structure
@code{XML_ParsingStatus}.  It has the following fields:

@table @code
@item parsing
A fixnum.

@item final-buffer?
A boolean.
@end table
@end deftp


@defun make-xml-parsing-status @var{code} @var{boolean}
Build and return a new instance of @code{xml-parsing-status}.
@end defun


@defun xml-parsing-status? @var{obj}
Return true if @var{obj} is an instance of @code{xml-parsing-status}.
@end defun


@defun xml-parsing-status-parsing @var{stru}
@defunx xml-parsing-status-final-buffer? @var{stru}
Accessors for the fields of @code{xml-parsing-status} instances.
@end defun


@defun XML_GetParsingStatus @var{parser}
@expatref{api parse, XML_GetParsingStatus}.  Acquire the current status
of the parser and return an instance of @code{xml-parsing-status}.
@end defun

@c page
@node parsers report
@section Reporting errors


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@defun XML_GetErrorCode @var{parser}
@expatref{api report, XML_GetErrorCode}.  Return a fixnum representing
an error code for the last error while parsing.
@end defun


@defun XML_ErrorString @var{code}
@expatref{api report, XML_ErrorString}.  Return a Scheme string
describing the error associated to @var{code}, which must be the return
value of @func{XML_GetErrorCode}.
@end defun


@defun XML_GetCurrentByteIndex @var{parser}
@defunx XML_GetCurrentColumnNumber @var{parser}
@defunx XML_GetCurrentByteIndex @var{parser}
@defunx XML_GetCurrentByteCount @var{parser}
@expatref{api report, XML_GetCurrentByteIndex}.  Inspect the current
parsing position.
@end defun

@c page
@node parsers misc
@section Miscellaneous functions


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@defun XML_SetUserData @var{parser} @var{pointer}
@defunx XML_GetUserData @var{parser}
@expatref{api misc, XML_SetUserData}.  Setter and getter for custom data
pointer used as first argument to many handlers.
@end defun


@defun XML_UseParserAsHandlerArg @var{parser}
@expatref{api misc, XML_UseParserAsHandlerArg}.  Set the parser pointer
as first argument to many handlers.
@end defun


@defun XML_SetBase @var{parser} @var{base}
@expatref{api misc, XML_SetBase}.  Set the base to resolve relative
@uri{}s.  @var{base} can be a bytevector representing a string or
@false{}, in which case the base is reset.
@end defun


@defun XML_GetBase @var{parser}
@expatref{api misc, XML_GetBase}.  Get the base to resolve relative
@uri{}s and return it as bytevector.  If there is no base set: the
return value is @false{}.
@end defun


@defun XML_GetSpecifiedAttributeCount @var{parser}
@expatref{api misc, XML_GetSpecifiedAttributeCount}.  Refer to the
original documentation.
@end defun


@defun XML_GetIdAttributeIndex @var{parser}
@expatref{api misc, XML_GetIdAttributeIndex}.  Refer to the original
documentation.
@end defun


@defun XML_UseForeignDTD @var{parser} @var{use-dtd?}
@expatref{api misc, XML_UseForeignDTD}.  If @var{use-dtd?} is true:
allow the application to provide an external @dtd{}.  Return a fixnum
representing an error code, if successful @code{XML_ERROR_NONE}.
@end defun

@c page
@node handlers
@chapter Building and registering callbacks


Expat offers a significant number of callbacks to process input from the
@axml{} document.  If we do not register any handler: the parsing
process will proceed successfully producing no side effects in the
program.

In the descriptions of this chapters: @var{parser} is a pointer of type
@code{XML_Parser}; @var{scheme-callback} is a Scheme function used as
callback; @var{c-callback}, @var{start-c-callback} and
@var{end-c-callback} are pointers referencing C language callbacks.

Unless otherwise specified, the Scheme callbacks will be called with
Scheme arguments that are the direct conversion of C language arguments:
C pointers become pointer objects, C integers become Scheme exact
intgers, and so on.

@menu
* handlers xml decl::           @axml{} declaration handler.
* handlers standalone::         Non--standalone handler.
* handlers dtd doctype::        @dtd{} document type declaration.
* handlers dtd element::        @dtd{} element declaration.
* handlers dtd attlist::        @dtd{} attribute lists declaration.
* handlers dtd notation::       @dtd{} notation declaration.
* handlers dtd entity::         @dtd{} entity declaration.
* handlers element::            Element handlers.
* handlers char data::          Character data handlers.
* handlers comment::            Comment handlers.
* handlers cdata::              Cdata handler.
* handlers namespace::          Namespace handlers.
* handlers default::            Default handler.
* handlers entity::             Special entity handlers.
* handlers procinst::           Processing instruction handlers.
@end menu

@c page
@node handlers xml decl
@section @axml{} declaration handler


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_XmlDeclHandler @var{scheme-callback}
@defunx XML_SetXmlDeclHandler @var{parser} @var{c-callback}
@expatref{api misc, XML_XmlDeclHandler}.  Maker and setter for @axml{}
declaration handlers and text declaration handlers.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (%process-standalone standalone)
  (case standalone
    ((-1)     'unspecified)
    ((0)      'non-standalone)
    ((1)      'standalone)
    (else     #f)))

(define (xml-decl-callback user-data version
                           encoding standalone)
  (pretty-print
   (list 'xml-decl
         (or (ffi.pointer-null?   version)
             (ffi.cstring->string version))
         (or (ffi.pointer-null?   encoding)
             (ffi.cstring->string encoding))
         (%process-standalone standalone))))

(define (doit xml-utf8)
  (let ((parser       (XML_ParserCreate))
        (xml-decl     (XML_XmlDeclHandler xml-decl-callback)))
    (XML_SetXmlDeclHandler parser xml-decl)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback xml-decl)
    (flush-output-port (current-output-port))))
@end example

@noindent
@axml{} declarations generate the following symbolic expressions:

@example
(doit
  (string->utf8
    "<?xml version='1.0'?>
     <toys><ball colour='red'/></toys>"))
@print{} (xml-decl "1.0" #t unspecified)

(doit
  (string->utf8
    "<?xml version='1.0' encoding='utf-8'?>
     <toys><ball colour='red'/></toys>"))
@print{} (xml-decl "1.0" "utf-8" unspecified)

(doit
  (string->utf8
    "<?xml version='1.0' standalone='yes'?>
     <toys><ball colour='red'/></toys>"))
@print{} (xml-decl "1.0" #t standalone)

(doit
  (string->utf8
    "<?xml version='1.0' standalone='no'?>
    <toys><ball colour='red'/></toys>"))
@print{} (xml-decl "1.0" #t non-standalone)
@end example

Now let's consider a program preamble in which an external @dtd{} is
expected and defined:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (%process-standalone standalone)
  (case standalone
    ((-1)     'unspecified)
    ((0)      'non-standalone)
    ((1)      'standalone)
    (else     #f)))

(define (xml-decl-callback user-data version encoding standalone)
  (pretty-print
   (list 'xml-decl
         (or (ffi.pointer-null?   version)
             (ffi.cstring->string version))
         (or (ffi.pointer-null?   encoding)
             (ffi.cstring->string encoding))
         (%process-standalone standalone))))

(define dtd-utf8
  (string->utf8
   "<?xml version='1.0' encoding='utf-8'?>
    <!ELEMENT ball EMPTY>
    <!ATTLIST ball colour CDATA #REQUIRED>"))

(define (external-entity-callback parser context base
                                  system-id public-id)
  (pretty-print
    (list 'external-entity
          (or (ffi.pointer-null?   context)
              (ffi.cstring->string context))
          (or (ffi.pointer-null?   base)
              (ffi.cstring->string base))
          (ffi.cstring->string system-id)
          (or (ffi.pointer-null?   public-id)
              (ffi.cstring->string public-id))))
  (let* ((parser   (XML_ExternalEntityParserCreate
                     parser context 'UTF-8))
         (xml-decl (XML_XmlDeclHandler xml-decl-callback)))
    (XML_SetXmlDeclHandler parser xml-decl)
    (let ((rv (XML_Parse parser dtd-utf8 #f #t)))
      (ffi.free-c-callback xml-decl)
      rv)))

(define (doit-with-external-entity xml-utf8)
  (let* ((parser   (XML_ParserCreate))
         (xml-decl (XML_XmlDeclHandler xml-decl-callback))
         (ext-ent  (XML_ExternalEntityRefHandler
                      external-entity-callback)))
    (XML_SetParamEntityParsing parser
       XML_PARAM_ENTITY_PARSING_ALWAYS)
    (XML_SetXmlDeclHandler parser xml-decl)
    (XML_SetExternalEntityRefHandler parser ext-ent)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback xml-decl)
    (ffi.free-c-callback ext-ent)
    (flush-output-port (current-output-port))))
@end example

@noindent
the following form:

@example
(doit-with-external-entity
  (string->utf8
    "<?xml version='1.0'?>
     <!DOCTYPE toys SYSTEM 'http://localhost/toys'>
     <toys><ball colour='red'/></toys>"))
@end example

@noindent
prints:

@example
(xml-decl "1.0" #t unspecified)
(external-entity #t #t "http://localhost/toys" #t)
(xml-decl "1.0" "utf-8" unspecified)
@end example

@noindent
showing the @axml{} declaration handler called twice.

@c page
@node handlers standalone
@section Non--standalone handler


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_NotStandaloneHandler @var{scheme-callback}
@defunx XML_SetNotStandaloneHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_NotStandaloneHandler}.  Maker and setter for
non--standalone declaration handler.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (%process-standalone standalone)
  (case standalone
    ((-1)     'unspecified)
    ((0)      'non-standalone)
    ((1)      'standalone)
    (else     #f)))

(define (xml-decl-callback user-data version
                           encoding standalone)
  (pretty-print
   (list 'xml-decl (%process-standalone standalone))))

(define (not-stand-callback user-data)
  (pretty-print '(not-standalone))
  XML_STATUS_OK)

(define (start-doctype-callback data doctype-name
                                sysid pubid
                                has-internal-subset)
  (pretty-print
   (list 'doctype-start has-internal-subset)))

(define (end-doctype-callback data)
  (pretty-print '(doctype-end)))

(define (doit xml-utf8)
  (let ((parser (XML_ParserCreate))
        (xml-decl
         (XML_XmlDeclHandler xml-decl-callback))
        (not-stand
         (XML_NotStandaloneHandler not-stand-callback))
        (dt-start
         (XML_StartDoctypeDeclHandler start-doctype-callback))
        (dt-end
         (XML_EndDoctypeDeclHandler end-doctype-callback)))
    (XML_SetXmlDeclHandler parser xml-decl)
    (XML_SetNotStandaloneHandler parser not-stand)
    (XML_SetStartDoctypeDeclHandler parser dt-start)
    (XML_SetEndDoctypeDeclHandler   parser dt-end)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback xml-decl)
    (ffi.free-c-callback not-stand)
    (ffi.free-c-callback dt-start)
    (ffi.free-c-callback dt-end)
    (flush-output-port (current-output-port))))
@end example

@noindent
the following forms print symbolic expressions:

@example
(doit (string->utf8
  "<?xml version='1.0'?>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl unspecified)

(doit (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys SYSTEM 'http://localhost/toys'>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl unspecified)
@print{} (not-standalone)
@print{} (doctype-start 0)
@print{} (doctype-end)

(doit (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys PUBLIC 'The Toys' 'http://localhost/toys'>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl unspecified)
@print{} (not-standalone)
@print{} (doctype-start 0)
@print{} (doctype-end)

;;;

(doit (string->utf8
  "<?xml version='1.0' standalone='no'?>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl non-standalone)

(doit (string->utf8
  "<?xml version='1.0' standalone='no'?>
   <!DOCTYPE toys SYSTEM 'http://localhost/toys'>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl non-standalone)
@print{} (not-standalone)
@print{} (doctype-start 0)
@print{} (doctype-end)

(doit (string->utf8
  "<?xml version='1.0' standalone='no'?>
   <!DOCTYPE toys PUBLIC 'The Toys' 'http://localhost/toys'>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl non-standalone)
@print{} (not-standalone)
@print{} (doctype-start 0)
@print{} (doctype-end)

;;;

(doit (string->utf8
  "<?xml version='1.0' standalone='yes'?>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl standalone)

(doit (string->utf8
  "<?xml version='1.0' standalone='yes'?>
   <!DOCTYPE toys SYSTEM 'http://localhost/toys'>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl standalone)
@print{} (doctype-start 0)
@print{} (doctype-end)

(doit (string->utf8
  "<?xml version='1.0' standalone='yes'?>
   <!DOCTYPE toys PUBLIC 'The Toys' 'http://localhost/toys'>
   <toys><ball colour='red'/></toys>"))
@print{} (xml-decl standalone)
@print{} (doctype-start 0)
@print{} (doctype-end)
@end example

@c page
@node handlers dtd doctype
@section @dtd{} document type declaration


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_StartDoctypeDeclHandler @var{scheme-callback}
@defunx XML_SetStartDoctypeDeclHandler @var{parser} @var{c-callback}
@expatref{api misc, XML_StartDoctypeDeclHandler}.  Maker and setter for
the start of document type declaration handlers.
@end defun


@defun XML_EndDoctypeDeclHandler @var{scheme-callback}
@defunx XML_SetEndDoctypeDeclHandler @var{parser} @var{c-callback}
@expatref{api misc, XML_EndDoctypeDeclHandler}.  Maker and setter for
the end of document type declaration handlers.
@end defun


@defun XML_SetDoctypeDeclHandler @var{parser} @var{start-c-callback} @var{end-c-callback}
@expatref{api misc, XML_SetDoctypeDeclHandler}.  Maker and setter for
both the start and end of document type declaration handlers.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (start-callback data doctype-name sysid pubid
                        has-internal-subset)
  (pretty-print
   (list 'doctype-start
         (ffi.cstring->string doctype-name)
         (or (ffi.pointer-null? sysid)
             (ffi.cstring->string sysid))
         (or (ffi.pointer-null? pubid)
             (ffi.cstring->string pubid))
         has-internal-subset)))

(define (end-callback data)
  (pretty-print '(doctype-end)))

(define (doit xml-utf8)
  (let ((parser (XML_ParserCreate))
        (start  (XML_StartDoctypeDeclHandler start-callback))
        (end    (XML_EndDoctypeDeclHandler   end-callback)))
    (XML_SetDoctypeDeclHandler parser start end)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback start)
    (ffi.free-c-callback end)
    (flush-output-port (current-output-port))))
@end example

@noindent
the following forms print symbolic expressions:

@example
(doit
 (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys SYSTEM 'http://localhost/toys'>
   <toys><ball colour='yellow'/></toys>"))
@print{} (doctype-start "toys" "http://localhost/toys" #t 0)
@print{} (doctype-end)

(doit
 (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys PUBLIC 'The Toys' 'http://localhost/toys'>
   <toys><ball colour='yellow'/></toys>")))
@print{} (doctype-start "toys" "http://localhost/toys" "The Toys" 0)
@print{} (doctype-end)

(doit
 (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys [
     <!ELEMENT ball EMPTY>
     <!ATTLIST ball colour CDATA #REQUIRED>
   ]>
   <toys><ball colour='yellow'/></toys>")))
@print{} (doctype-start "toys" #t #t 1)
@print{} (doctype-end)
@end example

@c page
@node handlers dtd element
@section @dtd{} element declaration


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_ElementDeclHandler @var{scheme-callback}
@defunx XML_SetElementDeclHandler @var{parser} @var{c-callback}
@expatref{api handlers dtd element, XML_ElementDeclHandler}.  Maker and
setter for the @dtd{} element declaration handlers.
@end defun


@defun XML_FreeContentModel @var{parser} @var{model}
@expatref{api handlers dtd element, XML_FreeContentModel}.  Release the
@var{model} arugment for the @code{XML_ElementDeclHandler}.
@end defun


@deftp {Structure Type} XML_Content
Scheme mirror of the C language type @code{XML_Content}.  It has the
following fields:

@table @code
@item type
One of the @code{XML_CTYPE_} constants.

@item quant
One of the @code{XML_CQUANT_} constants.

@item name
For root elements @false{}; for children elements: a Scheme string
representing the element's name.

@item numchildren
A non--negative fixnum representing the number of children elements.

@item children
@false{} or a vector of @code{XML_Content} structures representing the
children elements.
@end table
@end deftp


@defun make-XML_Content @var{type} @var{quant} @var{name} @var{numchildren} @var{children}
Maker for structures of type @code{XML_Content}.
@end defun


@defun XML_Content? @var{obj}
Return true if @var{obj} is an instance of @code{XML_Content}.
@end defun


@defun XML_Content-type @var{content}
@defunx XML_Content-quant @var{content}
@defunx XML_Content-name @var{content}
@defunx XML_Content-numchildren @var{content}
@defunx XML_Content-children @var{content}
Accessors for the fields of @code{XML_Content} structures.
@end defun


@defun pointer->XML_Content @var{pointer}
Given a pointer object referencing a C language @code{XML_Content}
structure: build and return a Scheme @code{XML_Content} structure
mirroring it.
@end defun


@defun XML_Content->list @var{content}
Given an instance to @code{XML_Content} return a list holding its fields
in the same order in which they appear in the structure definition.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (doit xml)
  (let ((xml-utf8 (string->utf8 xml))
        (parser   (XML_ParserCreate))
        (dtd-elm  (XML_ElementDeclHandler dtd-elm-callback)))
    (XML_UseParserAsHandlerArg parser)
    (XML_SetElementDeclHandler parser dtd-elm)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback dtd-elm)
    (flush-output-port (current-output-port))))

(define (dtd-elm-callback data name model)
  (pretty-print
   (list 'dtd-element
         (ffi.cstring->string name)
         (pointer->XML_Content model)))
  (XML_FreeContentModel data model))
@end example

@noindent
the following forms print symbolic expressions:

@example
(doit "<!DOCTYPE toys [
         <!ELEMENT ball EMPTY>
       ]>
       <toys><ball/></toys>")
@print{} (dtd-element "ball"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_EMPTY quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])

(doit "<!DOCTYPE toys [
         <!ELEMENT ball ANY>
       ]>
       <toys><ball/></toys>")
@print{} (dtd-element "ball"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_ANY quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])

(doit "<!DOCTYPE toys [
         <!ELEMENT toys (ball)>
         <!ELEMENT ball EMPTY>
       ]>
       <toys><ball/></toys>")
@print{} (dtd-element "toys"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_SEQ quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=1
@print{}      children=#(#[expat:XML_Content
@print{}                    type=XML_CTYPE_NAME quant=XML_CQUANT_NONE
@print{}                    name="ball" numchildren=0 children=#f])])
@print{} (dtd-element "ball"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_EMPTY quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])

(doit "<!DOCTYPE outer [
         <!ELEMENT outer (middle)>
         <!ELEMENT middle (inner)>
         <!ELEMENT inner EMPTY>
       ]>
       <outer><middle><inner/></middle></outer>")
@print{} (dtd-element "outer"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_SEQ quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=1
@print{}      children=#(#[expat:XML_Content
@print{}                    type=XML_CTYPE_NAME quant=XML_CQUANT_NONE
@print{}                    name="middle" numchildren=0 children=#f])])
@print{} (dtd-element "middle"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_SEQ quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=1
@print{}      children=#(#[expat:XML_Content
@print{}                    type=XML_CTYPE_NAME quant=XML_CQUANT_NONE
@print{}                    name="inner" numchildren=0 children=#f])])
@print{} (dtd-element "inner"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_EMPTY quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])

(doit "<!DOCTYPE this [
         <!ELEMENT this (#PCDATA)>
       ]>
       <this>ciao</this>")
@print{} (dtd-element "this"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_MIXED quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])

(doit "<!DOCTYPE this [
         <!ELEMENT this (#PCDATA|that)*>
         <!ELEMENT that EMPTY>
       ]>
       <this><that/></this>")
@print{} (dtd-element "this"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_MIXED quant=XML_CQUANT_REP
@print{}      name=#f numchildren=1
@print{}      children=#(#[expat:XML_Content
@print{}                    type=XML_CTYPE_NAME quant=XML_CQUANT_NONE
@print{}                    name="that" numchildren=0 children=#f])])
@print{} (dtd-element "that"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_EMPTY quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])

;;; quantifiers

(doit "<!DOCTYPE toys [
         <!ELEMENT toys (ball)*>
         <!ELEMENT ball EMPTY>
       ]>
       <toys><ball/></toys>")
@print{} (dtd-element "toys"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_SEQ quant=XML_CQUANT_REP
@print{}      name=#f numchildren=1
@print{}      children=#(#[expat:XML_Content
@print{}                    type=XML_CTYPE_NAME quant=XML_CQUANT_NONE
@print{}                    name="ball" numchildren=0 children=#f])])
@print{} (dtd-element "ball"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_EMPTY quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])

(doit "<!DOCTYPE toys [
         <!ELEMENT toys (ball)?>
         <!ELEMENT ball EMPTY>
       ]>
       <toys><ball/></toys>")
@print{} (dtd-element "toys"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_SEQ quant=XML_CQUANT_OPT
@print{}      name=#f numchildren=1
@print{}      children=#(#[expat:XML_Content
@print{}                    type=XML_CTYPE_NAME quant=XML_CQUANT_NONE
@print{}                    name="ball" numchildren=0 children=#f])])
@print{} (dtd-element "ball"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_EMPTY quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])

(doit "<!DOCTYPE toys [
         <!ELEMENT toys (ball)+>
         <!ELEMENT ball EMPTY>
       ]>
       <toys><ball/></toys>")
@print{} (dtd-element "toys"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_SEQ quant=XML_CQUANT_PLUS
@print{}      name=#f numchildren=1
@print{}      children=#(#[expat:XML_Content
@print{}                    type=XML_CTYPE_NAME quant=XML_CQUANT_NONE
@print{}                    name="ball" numchildren=0 children=#f])])
@print{} (dtd-element "ball"
@print{}   #[expat:XML_Content
@print{}      type=XML_CTYPE_EMPTY quant=XML_CQUANT_NONE
@print{}      name=#f numchildren=0 children=#f])
@end example

@c page
@node handlers dtd attlist
@section @dtd{} attribute lists declaration


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_AttlistDeclHandler @var{scheme-callback}
@defunx XML_SetAttlistDeclHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_AttlistDeclHandler}.  Maker and setter for
attributes list @dtd{} declaration handlers.
@end defun


Given the following program preamble:

@smallexample
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (doit xml)
  (let* ((xml-utf8    (string->utf8 xml))
         (parser      (XML_ParserCreate))
         (dtd-attlist
          (XML_AttlistDeclHandler dtd-attlist-callback))
         (elm-start
          (XML_StartElementHandler elm-start-callback)))
    (XML_SetAttlistDeclHandler parser dtd-attlist)
    (XML_SetStartElementHandler parser elm-start)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback dtd-attlist)
    (ffi.free-c-callback elm-start)
    (flush-output-port (current-output-port))))

(define (dtd-attlist-callback user-data element-name
                              attribute-name attribute-type
                              default-value required?)
  (pretty-print
   (list 'dtd-attlist
         (ffi.cstring->string element-name)
         (ffi.cstring->string attribute-name)
         (ffi.cstring->string attribute-type)
         (if (ffi.pointer-null? default-value)
             'no-value
           (ffi.cstring->string default-value))
         (fxpositive? required?))))

(define (elm-start-callback data element attributes)
  (pretty-print
   (list 'element-start
         (ffi.cstring->string element)
         (ffi.argv->strings attributes))))
@end smallexample

@noindent
the following forms print symbolic expressions:

@example
(doit "<!DOCTYPE toys [
         <!ELEMENT ball EMPTY>
         <!ATTLIST ball colour CDATA #REQUIRED>
       ]>
       <toys><ball colour='red' /></toys>")
@print{} (dtd-attlist "ball" "colour" "CDATA" no-value #t)
@print{} (element-start "toys" ())
@print{} (element-start "ball" ("colour" "red"))

(doit "<!DOCTYPE toys [
         <!ELEMENT ball EMPTY>
         <!ATTLIST ball colour CDATA #IMPLIED>
       ]>
       <toys><ball colour='red'/></toys>")
@print{} (dtd-attlist "ball" "colour" "CDATA" no-value #f)
@print{} (element-start "toys" ())
@print{} (element-start "ball" ("colour" "red"))

(doit "<!DOCTYPE toys [
         <!ELEMENT ball EMPTY>
         <!ATTLIST ball colour CDATA #FIXED 'red'>
       ]>
       <toys><ball/></toys>")
@print{} (dtd-attlist "ball" "colour" "CDATA" "red" #t)
@print{} (element-start "toys" ())
@print{} (element-start "ball" ("colour" "red"))

(doit "<!DOCTYPE toys [
         <!ELEMENT ball EMPTY>
         <!ATTLIST ball colour (red|blue|yellow) #REQUIRED>
       ]>
       <toys><ball colour='red' /></toys>")
@print{} (dtd-attlist "ball" "colour" "(red|blue|yellow)"
@print{}    no-value #t)
@print{} (element-start "toys" ())
@print{} (element-start "ball" ("colour" "red"))

(doit "<!DOCTYPE toys [
          <!ELEMENT ball EMPTY>
          <!ATTLIST ball colour CDATA 'red'>
       ]>
       <toys><ball/></toys>")
@print{} (dtd-attlist "ball" "colour" "CDATA" "red" #f)
@print{} (element-start "toys" ())
@print{} (element-start "ball" ("colour" "red"))
@end example

@c page
@node handlers dtd notation
@section @dtd{} notation declaration


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_NotationDeclHandler @var{scheme-callback}
@defunx XML_SetNotationDeclHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_NotationDeclHandler}.  Maker and setter for
@dtd{} notation handlers.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (%false-or-string thing)
  (if (ffi.pointer-null? thing)
      #f
    (ffi.cstring->string thing)))

(define (notation-callback data notation-name
                           base system-id public-id)
  (pretty-print
   (list 'notation
         (%false-or-string notation-name)
         (%false-or-string base)
         (%false-or-string system-id)
         (%false-or-string public-id))))

(define (doit xml-utf8)
  (let* ((parser      (XML_ParserCreate))
         (notation    (XML_NotationDeclHandler
                        notation-callback)))
    (XML_SetNotationDeclHandler parser notation)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback notation)
    (flush-output-port (current-output-port))))
@end example

@noindent
the following forms print symbolic expressions:

@example
(doit (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys [
     <!NOTATION bouncing SYSTEM
       'http://localhost/bouncer'>
     <!ELEMENT ball EMPTY>
     <!ATTLIST ball colour CDATA #REQUIRED>
   ]>
   <toys><ball colour='red' /></toys>"))
@print{} (notation "bouncing" #f "http://localhost/bouncer" #f)

(doit (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys [
     <!NOTATION bouncing PUBLIC 'The Bouncer'>
     <!ELEMENT ball EMPTY>
     <!ATTLIST ball colour CDATA #REQUIRED>
   ]>
   <toys><ball colour='red' /></toys>"))
@print{} (notation "bouncing" #f #f "The Bouncer")

(doit (string->utf8
  "<?xml version='1.0'?>
   <!DOCTYPE toys [
     <!NOTATION bouncing PUBLIC 'The Bouncer'
       'http://localhost/bouncer'>
     <!ELEMENT ball EMPTY>
     <!ATTLIST ball colour CDATA #REQUIRED>
   ]>
   <toys><ball colour='red' /></toys>"))
@print{} (notation "bouncing" #f
    "http://localhost/bouncer" "The Bouncer")
@end example

@c page
@node handlers dtd entity
@section @dtd{} entity declaration


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_EntityDeclHandler @var{scheme-callback}
@defunx XML_SetEntityDeclHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_EntityDeclHandler}.  Maker and setter for
the entity @dtd{} declaration handler.
@end defun


@defun XML_UnparsedEntityDeclHandler @var{scheme-callback}
@defunx XML_SetUnparsedEntityDeclHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_UnparsedEntityDeclHandler}.  Maker and
setter for unparsed entity @dtd{} declaration handler.  Usage of these
bindings is deprecated.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (%false-or-string thing)
  (if (ffi.pointer-null? thing)
      #f
    (ffi.cstring->string thing)))

(define (doit xml)
  (let* ((xml-utf8    (string->utf8 xml))
         (parser      (XML_ParserCreate))
         (dtd-entity
          (XML_EntityDeclHandler dtd-entity-callback))
         (elm-start
          (XML_StartElementHandler elm-start-callback)))
    (XML_SetBase parser (string->utf8 "http://localhost/"))
    (XML_SetParamEntityParsing parser
       XML_PARAM_ENTITY_PARSING_ALWAYS)
    (XML_SetEntityDeclHandler parser dtd-entity)
    (XML_SetStartElementHandler parser elm-start)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback dtd-entity)
    (ffi.free-c-callback elm-start)
    (flush-output-port (current-output-port))))

(define (dtd-entity-callback data entity-name
                             is-parameter-entity
                             value value-length
                             base system-id public-id
                             notation-name)
  (pretty-print
   (list 'dtd-entity
         (%false-or-string entity-name)
         (fxpositive? is-parameter-entity)
         (if (ffi.pointer-null? value)
             #f
           (ffi.cstring->string value value-length))
         (%false-or-string base)
         (%false-or-string system-id)
         (%false-or-string public-id)
         (%false-or-string notation-name))))

(define (elm-start-callback data element attributes)
  (pretty-print
   (list 'element-start
         (ffi.cstring->string element)
         (ffi.argv->strings attributes))))
@end example

@noindent
the following forms print symbolic expressions:

@example
;; general internal entity
(doit "<?xml version='1.0'?>
       <!DOCTYPE thing [
         <!ELEMENT thing EMPTY>
         <!ATTLIST thing frob (a|b|c) #REQUIRED>
         <!ENTITY stuff 'a'>
       ]>
       <thing frob='&stuff;'/>")
@print{} (dtd-entity "stuff" #f "a" "http://localhost/" #f #f #f)
@print{} (element-start "thing" ("frob" "a"))

;; general external entity, SYSTEM
(doit "<?xml version='1.0'?>
       <!DOCTYPE thing [
         <!ELEMENT thing EMPTY>
         <!ENTITY stuff SYSTEM 'http://localhost/stuff'>
       ]>
       <thing/>")
@print{} (dtd-entity "stuff" #f #f "http://localhost/"
@print{}   "http://localhost/stuff" #f #f)
@print{} (element-start "thing" ())

;; general external entity, PUBLIC
(doit "<?xml version='1.0'?>
       <!DOCTYPE thing [
         <!ELEMENT thing EMPTY>
         <!ENTITY stuff PUBLIC 'The Stuff' 'http://localhost/stuff'>
       ]>
       <thing/>")
@print{} (dtd-entity "stuff" #f #f "http://localhost/"
@print{}   "http://localhost/stuff" "The Stuff" #f)
@print{} (element-start "thing" ())

;; general external entity, SYSTEM with notation
(doit "<?xml version='1.0'?>
       <!DOCTYPE thing [
         <!ELEMENT thing EMPTY>
         <!NOTATION stuffer SYSTEM 'http://localhost/stuffer'>
         <!ENTITY stuff SYSTEM 'http://localhost/stuff' NDATA stuffer>
       ]>
       <thing/>")
@print{} (dtd-entity "stuff" #f #f "http://localhost/"
@print{}   "http://localhost/stuff" #f "stuffer")
@print{} (element-start "thing" ())

;; general external entity, PUBLIC with notation
(doit "<?xml version='1.0'?>
       <!DOCTYPE thing [
         <!ELEMENT thing EMPTY>
         <!NOTATION stuffer SYSTEM 'http://localhost/stuffer'>
         <!ENTITY stuff PUBLIC 'The Stuff' 'http://localhost/stuff' NDATA stuffer>
       ]>
       <thing/>")
@print{} (dtd-entity "stuff" #f #f "http://localhost/"
@print{}   "http://localhost/stuff" "The Stuff" "stuffer")
@print{} (element-start "thing" ())

;;;

;; parameter internal entity
(doit "<?xml version='1.0'?>
       <!DOCTYPE thing [
         <!ENTITY % stuff 'a'>
         <!ELEMENT thing EMPTY>
         <!ATTLIST thing>
       ]>
       <thing/>")
@print{} (dtd-entity "stuff" #t "a" "http://localhost/" #f #f #f)
@print{} (element-start "thing" ())

;; parameter external entity, SYSTEM
(doit "<?xml version='1.0'?>
       <!DOCTYPE thing [
         <!ELEMENT thing EMPTY>
         <!ENTITY % stuff SYSTEM 'http://localhost/stuff'>
       ]>
       <thing/>")
@print{} (dtd-entity "stuff" #t #f "http://localhost/"
@print{}   "http://localhost/stuff" #f #f)
@print{} (element-start "thing" ())

;; parameter external entity, PUBLIC
(doit "<?xml version='1.0'?>
       <!DOCTYPE thing [
         <!ELEMENT thing EMPTY>
         <!ENTITY % stuff PUBLIC 'The Stuff' 'http://localhost/stuff'>
       ]>
       <thing/>")
@print{} (dtd-entity "stuff" #t #f "http://localhost/"
@print{}   "http://localhost/stuff" "The Stuff" #f)
@print{} (element-start "thing" ())
@end example

@c page
@node handlers element
@section Element handlers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_StartElementHandler @var{scheme-callback}
@defunx XML_SetStartElementHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_StartElementHandler}.  Maker and setter for
the element start handler.
@end defun


@defun XML_EndElementHandler @var{scheme-callback}
@defunx XML_SetEndElementHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_EndElementHandler}.  Maker and setter for
the element end handler.
@end defun


@defun XML_SetElementHandler @var{parser} @var{start-c-callback} @var{end-c-callback}
@expatref{api handlers, XML_StartElementHandler}.  Setter for both the
element start and end handlers.
@end defun


The following program:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<!-- this is a test document -->\
    <stuff>\
      <thing colour=\"yellow\">\
        <alpha>one</alpha>\
        <beta>two</beta>\
      </thing>\
      <thing>\
        <alpha>123</alpha>\
        <beta>456</beta>\
      </thing>\
    </stuff>"))

(define (start-callback data element attributes)
  (pretty-print
    (list 'start
          (ffi.cstring->string element)
          (ffi.argv->strings attributes))))

(define (end-callback data element)
  (pretty-print
    (list 'end
          (ffi.cstring->string element))))

(let ((parser  (XML_ParserCreate))
      (start   (XML_StartElementHandler start-callback))
      (end     (XML_EndElementHandler   end-callback)))
  (XML_SetElementHandler parser start end)
  (XML_Parse parser xml-utf8 #f #t)
  (ffi.free-c-callback start)
  (ffi.free-c-callback end)
  (flush-output-port (current-output-port)))
@end example

@noindent
prints:

@example
(start "stuff" ())
(start "thing" ("colour" "yellow"))
(start "alpha" ())
(end "alpha")
(start "beta" ())
(end "beta")
(end "thing")
(start "thing" ())
(start "alpha" ())
(end "alpha")
(start "beta" ())
(end "beta")
(end "thing")
(end "stuff")
@end example

@c page
@node handlers char data
@section Character data handlers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_CharacterDataHandler @var{scheme-callback}
@defunx XML_SetCharacterDataHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_CharacterDataHandler}.  Maker and setter for
the character data handler.  Such handlers may be called multiple times
to process a single character data string.
@end defun


The following program:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<!-- this is a test document -->\
    <stuff>\
      <thing colour=\"yellow\">\
        <alpha>one</alpha>\
        <beta>two</beta>\
      </thing>\
      <thing>\
        <alpha>123</alpha>\
        <beta>456</beta>\
      </thing>\
    </stuff>"))

(define (text-callback data buf.ptr buf.len)
  (pretty-print
   (list 'text
         (ffi.cstring->string buf.ptr buf.len))))

(let ((parser  (XML_ParserCreate))
      (text    (XML_CharacterDataHandler text-callback)))
  (XML_SetCharacterDataHandler parser text)
  (XML_Parse parser xml-utf8 #f #t)
  (ffi.free-c-callback text)
  (flush-output-port (current-output-port)))
@end example

@noindent
prints:

@example
(text "one")
(text "two")
(text "123")
(text "456")
@end example

@c page
@node handlers comment
@section Comment handlers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_CommentHandler @var{scheme-callback}
@defunx XML_SetCommentHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_CommentHandler}.  Maker and setter for the
comment handler.
@end defun


The following program:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<!-- this is a test document -->\
    <stuff>\
      <thing colour=\"yellow\">\
        <alpha>one</alpha>\
        <beta>two</beta>\
      </thing>\
      <thing>\
        <alpha>123</alpha>\
        <beta>456</beta>\
      </thing>\
    </stuff>"))

(define (comment-callback data cstr)
  (pretty-print
   (list 'comment
         (ffi.cstring->string cstr))))

(let ((parser   (XML_ParserCreate))
      (comment  (XML_CommentHandler comment-callback)))
  (XML_SetCommentHandler parser comment)
  (XML_Parse parser xml-utf8 #f #t)
  (ffi.free-c-callback comment)
  (flush-output-port (current-output-port)))
@end example

@noindent
prints:

@example
(comment " this is a test document ")
@end example

@c page
@node handlers cdata
@section Cdata handler


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_StartCdataSectionHandler @var{scheme-callback}
@defunx XML_SetStartCdataSectionHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_StartCdataSectionHandler}.  Maker and setter
for the cdata start handler.
@end defun


@defun XML_EndCdataSectionHandler @var{scheme-callback}
@defunx XML_SetEndCdataSectionHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_EndCdataSectionHandler}.  Maker and setter
for the cdata end handler.
@end defun


@defun XML_SetCdataSectionHandler @var{parser} @var{start-c-callback} @var{end-c-callback}
@expatref{api handlers, XML_SetCdataSectionHandler}.  Setter for both
the cdata start and end handlers.
@end defun


The following program:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<stuff><![CDATA[ <stuff> ]]></stuff>"))

(define (start-cdata-callback data)
  (pretty-print '(start-cdata)))

(define (end-cdata-callback data)
  (pretty-print '(end-cdata)))

(define (text-callback data buf.ptr buf.len)
  (pretty-print
   (list 'text
         (ffi.cstring->string buf.ptr buf.len))))

(let ((parser       (XML_ParserCreate))
      (start        (XML_StartCdataSectionHandler start-cdata-callback))
      (end          (XML_EndCdataSectionHandler   end-cdata-callback))
      (text         (XML_CharacterDataHandler     text-callback)))
  (XML_SetCdataSectionHandler parser start end)
  (XML_SetCharacterDataHandler parser text)
  (XML_Parse parser xml-utf8 #f #t)
  (ffi.free-c-callback start)
  (ffi.free-c-callback end)
  (ffi.free-c-callback text)
  (flush-output-port (current-output-port)))
@end example

@noindent
prints:

@example
(start-cdata)
(text " <stuff> ")
(end-cdata)
@end example

@c page
@node handlers namespace
@section Namespace handlers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_EndNamespaceDeclHandler @var{scheme-callback}
@defunx XML_SetEndNamespaceDeclHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_EndNamespaceDeclHandler}.  Maker and setter
for the end--of--namespace handler.
@end defun


@defun XML_StartNamespaceDeclHandler @var{scheme-callback}
@defunx XML_SetStartNamespaceDeclHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_StartNamespaceDeclHandler}.  Maker and
setter for the start--of--namespace handler.
@end defun


@defun XML_SetNamespaceDeclHandler @var{parser} @var{start-c-callback} @var{end-c-callback}
@expatref{api handlers, XML_SetNamespaceDeclHandler}.  Setter for both
the start and end of namespace handlers.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (start-element-callback data element attributes)
  (pretty-print
   (list 'element-start
         (ffi.cstring->string element)
         (ffi.argv->strings attributes))))

(define (end-element-callback data element)
  (pretty-print
   (list 'element-end
         (ffi.cstring->string element))))

(define (start-xmlns-callback data prefix uri)
  (pretty-print
   (list 'xmlns-start
         (or (ffi.pointer-null? prefix)
             (ffi.cstring->string prefix))
         (or (ffi.pointer-null? uri)
             (ffi.cstring->string uri)))))

(define (end-xmlns-callback data prefix)
  (pretty-print
   (list 'xmlns-end
         (or (ffi.pointer-null? prefix)
             (ffi.cstring->string prefix)))))

(define (doit xml-utf8)
  (let ((parser (XML_ParserCreateNS 'UTF-8 #\:))
        (start-elm
         (XML_StartElementHandler start-element-callback))
        (end-elm
         (XML_EndElementHandler end-element-callback))
        (start-ns
         (XML_StartNamespaceDeclHandler start-xmlns-callback))
        (end-ns
         (XML_EndNamespaceDeclHandler end-xmlns-callback)))
    (XML_SetElementHandler parser start-elm end-elm)
    (XML_SetNamespaceDeclHandler parser start-ns  end-ns)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback start-elm)
    (ffi.free-c-callback end-elm)
    (ffi.free-c-callback start-ns)
    (ffi.free-c-callback end-ns)
    (flush-output-port (current-output-port))))
@end example

@noindent
the following forms print symbolic expressions:

@example
;; some namespaces
(doit
  (string->utf8
    "<?xml version='1.0'?>
     <!DOCTYPE toys [
       <!ELEMENT ball EMPTY>
       <!ATTLIST ball colour CDATA #REQUIRED>
     ]>
     <toys xmlns:blue='http://localhost/blue'
           xmlns:red='http://localhost/red'>\
       <blue:ball colour='yellow'/>\
       <red:ball  colour='purple'/>\
     </toys>"))
@print{} (xmlns-start "blue" "http://localhost/blue")
@print{} (xmlns-start "red" "http://localhost/red")
@print{} (element-start "toys" ())
@print{} (element-start "http://localhost/blue:ball"
@print{}    ("colour" "yellow"))
@print{} (element-end "http://localhost/blue:ball")
@print{} (element-start "http://localhost/red:ball"
@print{}    ("colour" "purple"))
@print{} (element-end "http://localhost/red:ball")
@print{} (element-end "toys")
@print{} (xmlns-end "red")
@print{} (xmlns-end "blue")

;; default namespace
(doit
  (string->utf8
    "<?xml version='1.0'?>
     <!DOCTYPE toys [
       <!ELEMENT ball EMPTY>
       <!ATTLIST ball colour CDATA #REQUIRED>
     ]>
     <toys xmlns='http://localhost/blue'>
       <ball colour='yellow'/>
       <ball  colour='purple'/>
     </toys>"))
@print{} (xmlns-start #t "http://localhost/blue")
@print{} (element-start "http://localhost/blue:toys" ())
@print{} (element-start "http://localhost/blue:ball"
@print{}    ("colour" "yellow"))
@print{} (element-end "http://localhost/blue:ball")
@print{} (element-start "http://localhost/blue:ball"
@print{}    ("colour" "purple"))
@print{} (element-end "http://localhost/blue:ball")
@print{} (element-end "http://localhost/blue:toys")
@print{} (xmlns-end #t)
@end example

@c page
@node handlers default
@section Default handler


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_DefaultHandler @var{scheme-callback}
@defunx XML_SetDefaultHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_DefaultHandler}.  Maker and setter for the
default handler.
@end defun


@defun XML_SetDefaultHandlerExpand @var{parser} @var{c-callback}
@expatref{api handlers, XML_SetDefaultHandlerExpand}.  Alternative
setter for the default handler which does not inhibit the expansion of
internal entity references.
@end defun


@defun XML_DefaultCurrent @var{parser}
@expatref{api misc, XML_DefaultCurrent}.  This function can be called
within a handler for a start element, end element, processing
instruction or character data.  It causes the corresponding markup to be
passed to the default handler set by @cfunc{XML_SetDefaultHandler} or
@cfunc{XML_SetDefaultHandlerExpand}.  It does nothing if there is not a
default handler.
@end defun


Given the following program opening:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (doit xml-utf8)
  (define (start-callback data element attributes)
    (XML_DefaultCurrent data))
  (define (end-callback data element)
    (XML_DefaultCurrent data))
  (define (default-callback user-data buf.ptr buf.len)
    (pretty-print
      (list 'default
            (ffi.cstring->string buf.ptr buf.len))))
  (let ((parser   (XML_ParserCreateNS 'UTF-8 #\:))
        (start    (XML_StartElementHandler start-callback))
        (end      (XML_EndElementHandler   end-callback))
        (default  (XML_DefaultHandler      default-callback)))
    (XML_UseParserAsHandlerArg parser)
    (XML_SetElementHandler parser start end)
    (XML_SetDefaultHandler parser default)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback start)
    (ffi.free-c-callback end)
    (ffi.free-c-callback default)
    (flush-output-port (current-output-port))))
@end example

@noindent
the following form:

@example
(doit (string->utf8
        "<toys><ball colour='yellow'/></toys>"))
@end example

@noindent
prints:

@example
(default "<toys>")
(default "<ball colour='yellow'/>")
(default "")
(default "</toys>")
@end example

@noindent
where the symbolic expression with the empty string is generated by a
call to the end--element handler for the standalone @code{<ball/>}
element.

@c page
@node handlers entity
@section Special entity handlers.


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_SkippedEntityHandler @var{scheme-callback}
@defunx XML_SetSkippedEntityHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_SkippedEntityHandler}.  Maker and setter for
the skipped entity handlers.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (doit xml)
  (let ((xml-utf8     (string->utf8 xml))
        (parser       (XML_ParserCreate))
        (skip-ent
         (XML_SkippedEntityHandler skipped-entity-callback)))
    (XML_SetSkippedEntityHandler parser skip-ent)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback skip-ent)
    (flush-output-port (current-output-port))))

(define (skipped-entity-callback data entity-name
                                 is-parameter-entity)
  (pretty-print
   (list 'skipped-entity
         (ffi.cstring->string entity-name)
         (fxpositive? is-parameter-entity))))
@end example

@noindent
the following forms print symbolic expressions:

@example
(doit "<?xml version='1.0' standalone='no'?>
       <!DOCTYPE thing SYSTEM 'http://localhost/thing'>
       <thing>&ciao;</thing>")
@print{} (skipped-entity "ciao" #f)
@end example

@c page
@node handlers procinst
@section Processing instruction handlers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_ProcessingInstructionHandler @var{scheme-callback}
@defunx XML_SetProcessingInstructionHandler @var{parser} @var{c-callback}
@expatref{api handlers, XML_ProcessingInstructionHandler}.  Maker and
setter for processing instruction handlers.
@end defun


Given the following program preamble:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define (doit xml)
  (let ((xml-utf8  (string->utf8 xml))
        (parser    (XML_ParserCreate))
        (proc-inst (XML_ProcessingInstructionHandler
                      processing-instruction-callback)))
    (XML_SetProcessingInstructionHandler parser proc-inst)
    (XML_Parse parser xml-utf8 #f #t)
    (ffi.free-c-callback proc-inst)
    (flush-output-port (current-output-port))))

(define (processing-instruction-callback user-data
                                         target data)
  (pretty-print
   (list 'processing-instruction
         (ffi.cstring->string target)
         (ffi.cstring->string data))))
@end example

@noindent
the following forms print symbolic expressions:

@example
(doit "<?xml version='1.0' standalone='no'?>
       <!DOCTYPE thing SYSTEM 'http://localhost/thing'>
       <thing><?scheme (display 123) ?></thing>")
@print{} (processing-instruction "scheme" "(display 123) ")
@end example

@c page
@node version
@chapter Expat version informations


The following bindings are exported by the @library{vicare expat}
library.


@defun XML_ExpatVersion
@expatref{api version, XML_ExpatVersion}.  Return a Scheme string
representing the Expat version number.
@end defun


@defun XML_ExpatVersionInfo
@expatref{api version, XML_ExpatVersionInfo}.  Return a Scheme vector
holding exact integers representing the Expat version numbers: major,
minor, micro.
@end defun


@defun XML_GetFeatureList
@expatref{api version, XML_GetFeatureList}.  Return a vector of vectors
representing the features of the running version of Expat.  Example:

@example
(XML_GetFeatureList)
@result{} #(#(6 "sizeof(XML_Char)" 1)
     #(7 "sizeof(XML_LChar)" 1)
     #(3 "XML_DTD" #f)
     #(4 "XML_CONTEXT_BYTES" 1024)
     #(8 "XML_NS" #f))
@end example
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @url{http://marcomaggi.github.com/docs/vicare-expat.html}

@noindent
the latest version of this package can be downloaded from:

@center @url{http://github.com/marcomaggi/vicare-expat/downloads}

@noindent
development takes place at:

@center @url{http://github.com/marcomaggi/vicare-expat/}

@noindent
the home page of the Vicare project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
the home page of the Nausicaa project is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
Expat can be found here:

@center @url{http://expat.sourceforge.net/}

@noindent
the @axml{} 1.0 specification is available from:

@center @url{http://www.w3.org/TR/REC-xml/}

the recommendation on Namespaces in @axml{} 1.0 is available from:

@center @url{<http://www.w3.org/TR/xml-names/}


@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

