\input texinfo.tex
@c %**start of header
@setfilename vicare-expat.info
@settitle Expat backend for Vicare
@c %**end of header

@include version.texi
@include macros.texi

@macro expatref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,expat}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Expat backend for Vicare

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare/Expat

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-expat

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi.ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2012


@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @version{} of @value{PACKAGE}, a
distribution of C and Scheme libraries for Vicare Scheme, an @rnrs{6}
compliant Scheme implementation; it provides bindings for the Expat C
language library, an @axml{} parser library.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}

@noindent
Expat is available at:

@center @url{http://expat.sourceforge.net/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-expat: (vicare-expat). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* parsers::                     Building and running parsers.
* handlers::                    Building and registering callbacks.
* version::                     Expat version informations.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


Vicare Scheme is an @rnrs{6} compliant Scheme language implementation in
the form of a native compiler for x86 architectures, officially
supporting @gnu{}+Linux systems.  @value{PACKAGE} is a distribution of C
language and Scheme language libraries for Vicare Scheme; it provides
bindings for the Expat C language library, an @axml{} parser library.

While @value{PACKAGE} can be used alone, its purpose is to provide a
backend Expat interface for Nausicaa/Expat: a higher level interface
adding syntactic sugar.

The last time the author bothered to update this paragraph, he had
tested Expat version 2.0.1; the Expat library is available at:

@center @url{http://expat.sourceforge.net/}

@noindent
notice that unofficial Expat documentation in Texinfo format is
available in the Nimby-Doc project at:

@center @url{http://github.com/marcomaggi/nimby-doc}

@noindent
and also online:

@center @url{http://marcomaggi.github.com/docs/expat.html}

Expat must be compiled to handle @utf{}-8 strings.

The package installs a C language library implementing wrapper C
functions for the C language Expat library; on top of this, the Scheme
library @library{vicare expat} exports one binding for each Expat public
function, with the exception of:

@example
XML_ParserCreateMM
XML_MemMalloc
XML_MemRealloc
XML_MemFree
@end example

@noindent
additionally the library @library{vicare expat constants} exports one
binding for each constant value defined in the C language header
@file{expat.h}.

Here is an example program:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<!-- this is a test document -->\
   <stuff>\
   <thing colour=\"yellow\">\
   <alpha>one</alpha>\
   <beta>two</beta>\
   </thing>\
   <thing>\
   <alpha>123</alpha>\
   <beta>456</beta>\
   </thing>\
   </stuff>"))

(define (start-callback data element attributes)
  (let ((element    (ffi.cstring->string element))
        (attributes (ffi.argv->strings attributes)))
    (pretty-print (list 'start element attributes))))

(define (end-callback data element)
  (let ((element (ffi.cstring->string element)))
    (pretty-print (list 'end element))))

(define (cdata-callback data buf.ptr buf.len)
  (let ((text (ffi.cstring->string buf.ptr buf.len)))
    (pretty-print (list 'cdata text))))

(define (comment-callback data cstr)
  (let ((text (ffi.cstring->string cstr)))
    (pretty-print (list 'comment text))))

(let ((parser   (XML_ParserCreate 'UTF-8))
      (start    (XML_StartElementHandler  start-callback))
      (end      (XML_EndElementHandler    end-callback))
      (cdata    (XML_CharacterDataHandler cdata-callback))
      (comment  (XML_CommentHandler       comment-callback)))
  (XML_SetElementHandler       parser start end)
  (XML_SetCharacterDataHandler parser cdata)
  (XML_SetCommentHandler       parser comment)
  (XML_Parse parser xml-utf8 #f #t)
  (ffi.free-c-callback start)
  (ffi.free-c-callback end)
  (ffi.free-c-callback cdata)
  (ffi.free-c-callback comment))

(flush-output-port (current-output-port))
@end example

@noindent
which prints:

@example
(comment " this is a test document ")
(start "stuff" ())
(start "thing" ("colour" "yellow"))
(start "alpha" ())
(cdata "one")
(end "alpha")
(start "beta" ())
(cdata "two")
(end "beta")
(end "thing")
(start "thing" ())
(start "alpha" ())
(cdata "123")
(end "alpha")
(start "beta" ())
(cdata "456")
(end "beta")
(end "thing")
(end "stuff")
@end example

@c page
@node parsers
@chapter Building and running parsers


@menu
* parsers create::              Creating parsers.
* parsers external::            Creating external entities parsers.
* parsers parsing::             Parsing data.
* parsers stop::                Stopping and resuming.
* parsers status::              Parsing status.
* parsers report::              Reporting errors.
* parsers misc::                Miscellaneous functions.
@end menu

@c page
@node parsers create
@section Creating parsers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_ParserCreate
@defunx XML_ParserCreate @var{encoding}
@expatref{api create, XML_ParserCreate}.  Build a new parser and return
a pointer object referencing it.  Values returned by this function must
be finalised with @func{XML_ParserFree}; this will happen automatically
when the pointer object is garbage collected.

The optional @var{encoding} must be one of the Scheme symbols:
@code{UTF-8}, @code{UTF-16}, @code{ISO-8859-1}, @code{US-ASCII} or
@false{}; when @var{encoding} is not used or it is @false{}: the parser
will honour the encoding specification in the document.
@end defun


@defun XML_ParserCreateNS @var{encoding} @var{namespace-separator}
@expatref{api create, XML_ParserCreateNS}.  Build a new parser, having
namespace processing in effect, and return a pointer object referencing
it.  Values returned by this function must be finalised with
@func{XML_ParserFree}; this will happen automatically when the pointer
object is garbage collected.

@var{encoding} is as in @func{XML_ParserCreate}.
@var{namespace-separator} must be a Scheme character in the @ascii{}
range.
@end defun


@defun XML_ParserFree @var{parser}
@expatref{api create, XML_ParserFree}.  Release all the resource
associated to the pointer object @var{parser}, then mutate @var{parser}
to represent the @cnull{} pointer; return unspecified values.  It is
safe to apply this function multiple times to the same @var{parser}
object: the first time it will release the resources, subsequent times
nothing will happen.
@end defun


@defun XML_ParserReset @var{parser}
@defunx XML_ParserReset @var{parser} @var{encoding}
@expatref{api create, XML_ParserReset}.  Reset a parser so that it can
be used again; return a boolean value: @true{} if success, @false{} if
this parser cannot be reset.  @var{encoding} is as in
@func{XML_ParserCreate}.
@end defun


@defun XML_SetEncoding @var{parser} @var{encoding}
@expatref{api misc, XML_SetEncoding}.  Set the encoding to be used while
parsing.  @var{encoding} is as in @func{XML_ParserCreate}.  Return a
fixnum representing a status code.
@end defun

@c page
@node parsers external
@section Creating external entities parsers


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_SetParamEntityParsing @var{parser} @var{code}
@expatref{api misc, XML_SetParamEntityParsing}.  Enable or disable
external entity parsing according to @var{code}, which must be a fixnum
among:

@example
XML_PARAM_ENTITY_PARSING_NEVER
XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE
XML_PARAM_ENTITY_PARSING_ALWAYS
@end example
@end defun


@defun XML_ExternalEntityParserCreate @var{parser} @var{context} @var{encoding}
@expatref{api create, XML_ExternalEntityParserCreate}.  Build a new
parser to parse an external entity for @var{parser} and return a pointer
object referencing it.  Values returned by this function must be
finalised with @func{XML_ParserFree}; this will happen automatically
when the pointer object is garbage collected.

@var{parser} is a pointer object to the main parser.  @var{context} must
be a pointer object.  @var{encoding} is as in @func{XML_ParserCreate}.
@end defun


The following is a skeleton program showing how to parse an external
@dtd{}:

@smallexample
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
    "<!DOCTYPE toys SYSTEM 'http://localhost/toys'>
     <toys><ball colour='red'/></toys>"))

(define dtd-utf8
  (string->utf8
    "<!ELEMENT ball EMPTY>
     <!ATTLIST ball colour CDATA #REQUIRED>"))

(define (handler parser context base system-id public-id)
  (let ((parser (XML_ExternalEntityParserCreate
                   parser context 'UTF-8)))
    (XML_Parse parser dtd-utf8 #f #t)
    XML_STATUS_OK))

(let* ((parser  (XML_ParserCreate 'UTF-8))
       (cb      (XML_ExternalEntityRefHandler scheme-callback)))
  (XML_SetParamEntityParsing parser
     XML_PARAM_ENTITY_PARSING_ALWAYS)
  (XML_SetExternalEntityRefHandler parser cb)
  (XML_Parse parser xml-utf8 #f #t)
  (ffi.free-c-callback cb))
@end smallexample

@c page
@node parsers parsing
@section Parsing data


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@defun XML_Parse @var{parser} @var{buffer} @var{buflen} @var{final?}
@expatref{api parse, XML_Parse}.  Parse the next portion of the
document; return a fixnum representing a status code.

@var{buffer} must be a bytevector or a pointer object.  @var{buflen}
must be @false{} or a non--negative exact integer in the range of the
@code{int} C language type.  @var{final?} must be a boolean object.

If @var{buffer} is a pointer: @var{buflen} must be an integer
representing the number bytes to consume from the buffer; if
@var{buffer} is a bytevector: @var{buflen} is ignored and the whole
bytevector is consumed.
@end defun

@c ------------------------------------------------------------

@subsubheading Parsing data from an internal buffer


@defun XML_GetBuffer @var{parser} @var{buflen}
@expatref{api parse, XML_GetBuffer}.  Allocate an internal buffer
@var{buflen} bytes wide and return a pointer object to it; return
@false{} if the allocation fails.  The returned value is meant to be
filled with the next portion of the document and processed by
@func{XML_ParseBuffer}.
@end defun


@defun XML_ParseBuffer @var{parser} @var{buflen} @var{final?}
@expatref{api parse, XML_ParseBuffer}.  Parse the next portion of the
document from the internal buffer allocated by a previous call to
@func{XML_GetBuffer}.  Return a fixnum representing a status code.
@end defun


The following skeleton program shows the mechanics of using an internal
buffer:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml
  (string->utf8
    "<!DOCTYPE toys SYSTEM 'http://localhost/toys'>
     <toys><ball colour='red'/></toys>"))

(let ((parser  (XML_ParserCreate 'UTF-8))
      (buflen  (bytevector-length data))
      (buffer  (XML_GetBuffer parser buflen)))
  (ffi.memory-copy buffer 0 data 0 buflen)
  (XML_ParseBuffer parser buflen #t))
@end example

@c page
@node parsers stop
@section Stopping and resuming


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@defun XML_StopParser @var{parser} @var{resumable?}
@expatref{api parse, XML_StopParser}.  Stop parsing causing the parse
function to return; return a fixnum representing a status code.
@var{resumable?} must be a boolean object.
@end defun


@defun XML_ResumeParser @var{parser}
@expatref{api parse, XML_ResumeParser}.  Resume parsing for a suspended
parser.  A call to this function is like a call to @func{XML_Parse} or
@func{XML_ParseBuffer}.
@end defun


The following skeleton program shows the mechanics of aborting parsing:

@example
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<?xml version='1.0'?>
    <!DOCTYPE toys [
      <!ELEMENT ball EMPTY>
      <!ATTLIST ball colour CDATA #REQUIRED>
    ]>
    <toys><ball colour='red'/></toys>"))

(define (start-callback parser element attributes)
  (let ((status (XML_GetParsingStatus parser)))
    (unless (= XML_STATUS_SUSPENDED
               (parsing-status-parsing status))
      (XML_StopParser parser #f))))

(let ((parser  (XML_ParserCreate))
      (start   (XML_StartElementHandler start-callback)))
  (XML_SetStartElementHandler parser start)
  (XML_SetUserData parser parser)
  (XML_Parse parser xml-utf8 #f #t)     @result{} XML_STATUS_ERROR
  (ffi.free-c-callback start)
  (XML_GetErrorCode parser))            @result{} XML_ERROR_ABORTED
@end example

@noindent
the following skeleton program shows the mechanics of stopping parsing
and then resuming:

@smallexample
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<?xml version='1.0'?>
    <!DOCTYPE toys [
      <!ELEMENT ball EMPTY>
      <!ATTLIST ball colour CDATA #REQUIRED>
    ]>
    <toys><ball colour='red'/></toys>"))

(define (start-callback-and-suspend parser element attributes)
  (XML_StopParser parser #t))

(define (start-callback parser element attributes)
  (void))

(let* ((parser   (XML_ParserCreate))
       (suspend  (XML_StartElementHandler start-callback-and-suspend)))
  (XML_SetStartElementHandler parser suspend)
  (XML_SetUserData parser parser)
  (XML_Parse parser xml-utf8 #f #t)     @result{} XML_STATUS_SUSPENDED
  (ffi.free-c-callback suspend)
  (let ((start (XML_StartElementHandler start-callback)))
    (XML_SetStartElementHandler parser start)
    (XML_ResumeParser parser)           @result{} XML_STATUS_OK
    (ffi.free-c-callback start)))
@end smallexample

@c page
@node parsers status
@section Parsing status


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@deftp {Structure Type} xml-parsing-status
@expatref{api parse, XML_ParsingStatus}.  Structure representing the
current parser status as mirror of the C data structure
@code{XML_ParsingStatus}.  It has the following fields:

@table @code
@item parsing
A fixnum.

@item final-buffer?
A boolean.
@end table
@end deftp


@defun make-xml-parsing-status @var{code} @var{boolean}
Build and return a new instance of @code{xml-parsing-status}.
@end defun


@defun xml-parsing-status? @var{obj}
Return true if @var{obj} is an instance of @code{xml-parsing-status}.
@end defun


@defun xml-parsing-status-parsing @var{stru}
@defunx xml-parsing-status-final-buffer? @var{stru}
Accessors for the fields of @code{xml-parsing-status} instances.
@end defun


@defun XML_GetParsingStatus @var{parser}
@expatref{api parse, XML_GetParsingStatus}.  Acquire the current status
of the parser and return an instance of @code{xml-parsing-status}.
@end defun

@c page
@node parsers report
@section Reporting errors


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@defun XML_GetErrorCode @var{parser}
@expatref{api report, XML_GetErrorCode}.  Return a fixnum representing
an error code for the last error while parsing.
@end defun


@defun XML_ErrorString @var{code}
@expatref{api report, XML_ErrorString}.  Return a Scheme string
describing the error associated to @var{code}, which must be the return
value of @func{XML_GetErrorCode}.
@end defun


@defun XML_GetCurrentByteIndex @var{parser}
@defunx XML_GetCurrentColumnNumber @var{parser}
@defunx XML_GetCurrentByteIndex @var{parser}
@defunx XML_GetCurrentByteCount @var{parser}
@expatref{api report, XML_GetCurrentByteIndex}.  Inspect the current
parsing position.
@end defun

@c page
@node parsers misc
@section Miscellaneous functions


All the following bindings are exported by the @library{vicare expat}
library.  In all the descriptions: the @var{parser} argument must be a
pointer object referencing the parser.


@defun XML_SetUserData @var{parser} @var{pointer}
@defunx XML_GetUserData @var{parser}
@expatref{api misc, XML_SetUserData}.  Setter and getter for custom data
pointer used as first argument to many handlers.
@end defun


@defun XML_UseParserAsHandlerArg @var{parser}
@expatref{api misc, XML_UseParserAsHandlerArg}.  Set the parser pointer
as first argument to many handlers.
@end defun


@defun XML_SetBase @var{parser} @var{base}
@expatref{api misc, XML_SetBase}.  Set the base to resolve relative
@uri{}s.  @var{base} can be a bytevector representing a string or
@false{}, in which case the base is reset.
@end defun


@defun XML_GetBase @var{parser}
@expatref{api misc, XML_GetBase}.  Get the base to resolve relative
@uri{}s and return it as bytevector.  If there is no base set: the
return value is @false{}.
@end defun


@defun XML_GetSpecifiedAttributeCount @var{parser}
@expatref{api misc, XML_GetSpecifiedAttributeCount}.  Refer to the
original documentation.
@end defun


@defun XML_GetIdAttributeIndex @var{parser}
@expatref{api misc, XML_GetIdAttributeIndex}.  Refer to the original
documentation.
@end defun


@defun XML_UseForeignDTD @var{parser} @var{use-dtd?}
@expatref{api misc, XML_UseForeignDTD}.  Allow the application to
provide an external @dtd{}.  Return a fixnum representing an error code,
if successful @code{XML_ERROR_NONE}.
@end defun


@defun XML_SetReturnNSTriplet @var{parser} @var{do-nst?}

@end defun


@defun XML_DefaultCurrent @var{parser}

@end defun


@defun XML_FreeContentModel @var{parser} @var{model}

@end defun

@c page
@node handlers
@chapter Building and registering callbacks


Expat offers a significant number of callbacks to process input from the
@axml{} document.  If we do not register any handler: the parsing
process will proceed successfully producing no side effect in the
program.

In the descriptions of this chapters: @var{scheme-callback} is a Scheme
function used as callback; @var{parser} is a pointer of type
@code{XML_Parser}; @var{c-callback}, @var{start-c-callback} and
@var{end-c-callback} are pointers referencing C language callbacks.

@menu
* handlers dtd attlist::        @dtd{} attribute lists.
* handlers misc::               Miscellaneous handlers.
@end menu

@c page
@node handlers dtd attlist
@section @dtd{} attribute lists


All the following bindings are exported by the @library{vicare expat}
library.


@defun XML_AttlistDeclHandler @var{scheme-callback}
@defunx XML_SetAttlistDeclHandler @var{parser} @var{c-callback}
Maker and setter for handlers of attributes list in the @dtd{}.  The
following program:

@smallexample
#!r6rs
(import (vicare)
  (vicare expat)
  (vicare expat constants)
  (prefix (vicare ffi) ffi.))

(define xml-utf8
  (string->utf8
   "<!DOCTYPE toys [
     <!ELEMENT ball EMPTY>
     <!ATTLIST ball colour CDATA #REQUIRED>
   ]>
   <toys><ball colour='red' /></toys>"))

(define (scheme-callback user-data element-name attribute-name
                         attribute-type default-value required?)
  (let ((element-name    (ffi.cstring->string element-name))
        (attribute-name  (ffi.cstring->string attribute-name))
        (attribute-type  (ffi.cstring->string attribute-type))
        (default-value   (if (ffi.pointer-null? default-value)
                             'NULL
                           (ffi.cstring->string default-value))))
    (pretty-print (list element-name attribute-name
                        attribute-type default-value
                        required?))))

(let ((parser  (XML_ParserCreate 'UTF-8))
      (cb      (XML_AttlistDeclHandler scheme-callback)))
  (XML_SetAttlistDeclHandler parser cb)
  (XML_Parse parser xml-utf8 #f #t)
  (ffi.free-c-callback cb))

(flush-output-port (current-output-port))
@end smallexample

@noindent
prints:

@example
("ball" "colour" "CDATA" NULL 1)
@end example
@end defun

@c page
@node handlers misc
@section Miscellaneous handlers


@defun XML_SetCdataSectionHandler @var{parser} @var{start-c-callback} @var{end-c-callback}
@end defun


@defun XML_CharacterDataHandler @var{scheme-callback}
@defunx XML_SetCharacterDataHandler @var{parser} @var{c-callback}
@end defun


@defun XML_StartCdataSectionHandler @var{scheme-callback}
@defunx XML_SetStartCdataSectionHandler @var{parser} @var{c-callback}
@end defun


@defun XML_EndCdataSectionHandler @var{scheme-callback}
@defunx XML_SetEndCdataSectionHandler @var{parser} @var{c-callback}
@end defun


@c ------------------------------------------------------------

@defun XML_CommentHandler @var{scheme-callback}
@defunx XML_SetCommentHandler @var{parser} @var{c-callback}
@end defun

@c ------------------------------------------------------------


@defun XML_DefaultHandler @var{scheme-callback}
@defunx XML_SetDefaultHandler @var{parser} @var{c-callback}
@end defun


@defun XML_SetDefaultHandlerExpand @var{parser} @var{c-callback}

@end defun


@defun XML_ElementDeclHandler @var{scheme-callback}
@defunx XML_SetElementDeclHandler @var{parser} @var{c-callback}
@end defun

@c ------------------------------------------------------------

@defun XML_SetDoctypeDeclHandler @var{parser} @var{start-c-callback} @var{end-c-callback}
@end defun


@defun XML_EndDoctypeDeclHandler @var{scheme-callback}
@defunx XML_SetEndDoctypeDeclHandler @var{parser} @var{c-callback}
@end defun

@c ------------------------------------------------------------

@defun XML_SetElementHandler @var{parser} @var{start-c-callback} @var{end-c-callback}

@end defun


@defun XML_EndElementHandler @var{scheme-callback}
@defunx XML_SetEndElementHandler @var{parser} @var{c-callback}
@end defun

@c ------------------------------------------------------------

@defun XML_SetNamespaceDeclHandler @var{parser} @var{start-c-callback} @var{end-c-callback}

@end defun


@defun XML_EndNamespaceDeclHandler @var{scheme-callback}
@defunx XML_SetEndNamespaceDeclHandler @var{parser} @var{c-callback}
@end defun


@defun XML_EntityDeclHandler @var{scheme-callback}
@defunx XML_SetEntityDeclHandler @var{parser} @var{c-callback}
@end defun


@defun XML_ExternalEntityRefHandler @var{scheme-callback}
@defunx XML_SetExternalEntityRefHandler @var{parser} @var{c-callback}
@end defun


@defun XML_NotStandaloneHandler @var{scheme-callback}
@defunx XML_SetNotStandaloneHandler @var{parser} @var{c-callback}
@end defun


@defun XML_NotationDeclHandler @var{scheme-callback}
@defunx XML_SetNotationDeclHandler @var{parser} @var{c-callback}
@end defun


@defun XML_ProcessingInstructionHandler @var{scheme-callback}
@defunx XML_SetProcessingInstructionHandler @var{parser} @var{c-callback}
@end defun


@defun XML_SkippedEntityHandler @var{scheme-callback}
@defunx XML_SetSkippedEntityHandler @var{parser} @var{c-callback}
@end defun


@defun XML_StartDoctypeDeclHandler @var{scheme-callback}
@defunx XML_SetStartDoctypeDeclHandler @var{parser} @var{c-callback}
@end defun


@defun XML_StartElementHandler @var{scheme-callback}
@defunx XML_SetStartElementHandler @var{parser} @var{c-callback}
@end defun


@defun XML_StartNamespaceDeclHandler @var{scheme-callback}
@defunx XML_SetStartNamespaceDeclHandler @var{parser} @var{c-callback}
@end defun


@defun XML_UnknownEncodingHandler @var{scheme-callback}
@defunx XML_SetUnknownEncodingHandler @var{parser} @var{c-callback}
@end defun


@defun XML_UnparsedEntityDeclHandler @var{scheme-callback}
@defunx XML_SetUnparsedEntityDeclHandler @var{parser} @var{c-callback}
@end defun


@defun XML_XmlDeclHandler @var{scheme-callback}
@defunx XML_SetXmlDeclHandler @var{parser} @var{c-callback}
@end defun

@c page
@node version
@chapter Expat version informations


The following bindings are exported by the @library{vicare expat}
library.


@defun XML_ExpatVersion
@expatref{api version, XML_ExpatVersion}.  Return a Scheme string
representing the Expat version number.
@end defun


@defun XML_ExpatVersionInfo
@expatref{api version, XML_ExpatVersionInfo}.  Return a Scheme vector
holding exact integers representing the Expat version numbers: major,
minor, micro.
@end defun


@defun XML_GetFeatureList
@expatref{api version, XML_GetFeatureList}.  Return a vector of vectors
representing the features of the running version of Expat.  Example:

@example
(XML_GetFeatureList)
@result{} #(#(6 "sizeof(XML_Char)" 1)
     #(7 "sizeof(XML_LChar)" 1)
     #(3 "XML_DTD" #f)
     #(4 "XML_CONTEXT_BYTES" 1024)
     #(8 "XML_NS" #f))
@end example
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @url{http://marcomaggi.github.com/docs/vicare-expat.html}

@noindent
the latest version of this package can be downloaded from:

@center @url{http://github.com/marcomaggi/vicare-expat/downloads}

@noindent
development takes place at:

@center @url{http://github.com/marcomaggi/vicare-expat/}

@noindent
the home page of the Vicare project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
the home page of the Nausicaa project is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
Expat can be found here:

@center @url{http://expat.sourceforge.net/}

@noindent
the @axml{} specification is available from:

@center @url{http://www.w3.org/TR/REC-xml/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

